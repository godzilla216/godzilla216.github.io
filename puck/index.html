<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Puck Duel Online</title>

<style>
body {
  background: #222;
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
}

canvas {
  background: #0a5;
  border: 4px solid #333;
  margin-top: 10px;
  touch-action: none;
}

#lobby {
  margin-bottom: 10px;
}

#status {
  margin-top: 6px;
  font-weight: bold;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>

<body>

<h1>Puck Duel</h1>

<div id="lobby">
  <button id="createBtn">Create Room</button>
  <input id="codeInput" placeholder="Room code" />
  <button id="joinBtn">Join Room</button>
  <button id="matchBtn">Quick Match</button>
  <button id="spectateBtn">Spectate</button>
  <div id="message" style="margin-top:6px; color:#f55; font-weight:bold;"></div>

  <div id="status">
    Room: <span id="roomLabel">-</span> |
    You: <span id="playerLabel">-</span>
  </div>
<div id="playerStats" style="margin-top:6px; font-size:16px; color:#0ff;">
  Online: 0 | Searching: 0
</div>
</div>

<div id="scoreboard" style="margin-bottom: 10px; font-size: 20px;">
  Player 1 Wins: <span id="player1Wins">0</span> |
  Player 2 Wins: <span id="player2Wins">0</span>
</div>

<div id="turnIndicator" style="margin-top:6px; font-size:18px; font-weight:bold;">
  Waiting for players...
</div>
  
<canvas id="game" width="800" height="500"></canvas>

<div id="gameOver" style="
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 48px;
  color: white;
  background: rgba(0,0,0,0.8);
  padding: 40px;
  border-radius: 20px;
  display: none;
  text-align: center;
  z-index: 100;">
  <span id="gameOverText"></span>
</div>

  
<script type="module">
/* ================= FIREBASE ================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  get,
  update,
  onValue
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDxoIs6Nn5dMCpPj8JjNqbv-O3SVpiac0A",
  authDomain: "login-6cdd8.firebaseapp.com",
  databaseURL: "https://login-6cdd8-default-rtdb.firebaseio.com",
  projectId: "login-6cdd8",
  storageBucket: "login-6cdd8.firebasestorage.app",
  messagingSenderId: "518535069226",
  appId: "1:518535069226:web:8925106a250805bbf24d53"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ================= LOBBY ================= */



  
const playerStatsEl = document.getElementById("playerStats");

// --- Track online players ---
const myId = uid();
const onlineRef = ref(db, `presence/${myId}`);

// Mark this client as online
set(onlineRef, { connectedAt: Date.now() });

// Remove on disconnect
import { onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
onDisconnect(onlineRef).remove();

// --- Realtime listener for online players ---
const presenceRef = ref(db, "presence");
onValue(presenceRef, snap => {
  const onlineUsers = snap.val() || {};
  updatePlayerStats(Object.keys(onlineUsers).length);
});

// --- Realtime listener for queue ---
const queueRef = ref(db, "matchmaking/queue");
onValue(queueRef, snap => {
  const queueUsers = snap.val() || {};
  updatePlayerStats(null, Object.keys(queueUsers).length);
});

// --- Helper to update combined text ---
let lastOnline = 0;
let lastQueue = 0;

function updatePlayerStats(online = null, queue = null) {
  if (online !== null) lastOnline = online;
  if (queue !== null) lastQueue = queue;

  playerStatsEl.textContent = `Online: ${lastOnline} | Searching: ${lastQueue}`;
}



let roomCode = null;
let myPlayer = null;
let isHost = false;
let bothPlayersReady = false;

const messageEl = document.getElementById("message");

document.getElementById("spectateBtn").onclick = async () => {
  const code = document.getElementById("codeInput").value.toUpperCase();
  if (!code) {
    messageEl.textContent = "Please enter a room code.";
    return;
  }

  const snap = await get(ref(db, "rooms/" + code));
  if (!snap.exists()) {
    messageEl.textContent = "Room not found.";
    return;
  }

  // Clear message on success
  messageEl.textContent = "";

  roomCode = code;
  myPlayer = 0; // 0 = spectator
  isHost = false; // spectators never host

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Spectator";

  bothPlayersReady = true; // allow state to be drawn
  aiming = false;

  listenState();

  document.getElementById("status").textContent = "Spectating";
};


  
function uid() {
  return Math.random().toString(36).substring(2);
}

const myMatchId = uid();
let inQueue = false;

window.addEventListener("beforeunload", () => {
  if (inQueue) {
    set(ref(db, `matchmaking/queue/${myMatchId}`), null);
  }
});
  
function generateCode() {
  return Math.random().toString(36).substring(2, 7).toUpperCase();
}
let roundEnded = false
document.getElementById("createBtn").onclick = async () => {
  const code = generateCode();

  await set(ref(db, "rooms/" + code), {
    players: { player1: true, player2: false },
    state: {
      phase: "aim",
      currentPlayer: 1,
      shotsTaken: { player1: 0, player2: 0 },
      maxShots: 3,
      pucks: []
    },
    scores: { player1: 0, player2: 0 } // add this
  });

  roomCode = code;
  myPlayer = 1;
  isHost = true;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 1";

if (isHost) {
  initGame();
}

listenPlayers();
listenState();
};

document.getElementById("joinBtn").onclick = async () => {
  const code = document.getElementById("codeInput").value.toUpperCase();
  const snap = await get(ref(db, "rooms/" + code));

  if (!snap.exists()) return alert("Room not found");
  if (snap.val().players.player2) return alert("Room full");

  await update(ref(db, "rooms/" + code + "/players"), { player2: true });

  roomCode = code;
  myPlayer = 2;
  isHost = false;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 2";

  listenPlayers();
  listenState();
};

/* ==================== */

document.getElementById("matchBtn").onclick = async () => {
  if (inQueue) return;
  inQueue = true;

  document.getElementById("roomLabel").textContent = "â€”";
  document.getElementById("playerLabel").textContent = "Matching";

  const myRef = ref(db, `matchmaking/queue/${myMatchId}`);
  await set(myRef, { joinedAt: Date.now() });

  const queueRef = ref(db, "matchmaking/queue");

  onValue(queueRef, async snap => {
    if (!inQueue) return;

    const queue = snap.val() || {};
    const ids = Object.keys(queue);

    // Need at least 2 people
    if (ids.length < 2) return;

    // Oldest player becomes host
    ids.sort((a, b) => queue[a].joinedAt - queue[b].joinedAt);

    if (ids[0] !== myMatchId) return; // not the host

    const otherId = ids[1];
    const code = generateCode();

    await set(ref(db, `rooms/${code}`), {
      players: { player1: true, player2: true },
      state: {
        phase: "aim",
        currentPlayer: 1,
        shotsTaken: { player1: 0, player2: 0 },
        maxShots: 3,
        pucks: []
      },
      scores: { player1: 0, player2: 0 }
    });

    await set(ref(db, `matchmaking/matches/${ids[0]}`), {
      room: code,
      player: 1
    });

    await set(ref(db, `matchmaking/matches/${ids[1]}`), {
      room: code,
      player: 2
    });

    await set(ref(db, `matchmaking/queue/${ids[0]}`), null);
    await set(ref(db, `matchmaking/queue/${ids[1]}`), null);

    inQueue = false;
  });

  waitForMatch();
};
  /*========================================================*/
  function waitForMatch() {
  onValue(ref(db, `matchmaking/matches/${myMatchId}`), snap => {
    if (!snap.exists()) return;

    const { room, player } = snap.val();
    joinMatchedRoom(room, player);

    set(ref(db, `matchmaking/queue/${myMatchId}`), null);
    set(ref(db, `matchmaking/matches/${myMatchId}`), null);
  });
}

function joinMatchedRoom(code, playerNum) {
  roomCode = code;
  myPlayer = playerNum;
  isHost = playerNum === 1;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = `Player ${playerNum}`;

  initGame();
  listenPlayers();
  listenState();

  document.getElementById("status").textContent = "Matched!";
}

/* ================= GAME ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const BOARD_MARGIN = 20;
const PUCK_RADIUS = 12;
const FRICTION = 0.99;

let pucks = [];
let phase = "aim";
let currentPlayer = 1;
let aiming = false;
let aimPos = null;

function createPucks() {
  pucks = [];
  for (let i = 0; i < 3; i++) {
    pucks.push({ x: 150, y: 150 + i*60, vx: 0, vy: 0, player: 1, active: true });
    pucks.push({ x: 650, y: 150 + i*60, vx: 0, vy: 0, player: 2, active: true });
  }
}

function getActivePucks(player) {
  return pucks.filter(p => p.player === player && p.active);
}

function getCurrentPuck() {
  const list = getActivePucks(currentPlayer);
  const idx = stateShots[`player${currentPlayer}`];

  // If player has no more pucks, return null
  if (!list || idx >= list.length) return null;

  return list[idx];
}



/* ================= INPUT ================= */
canvas.onmousedown = e => {
  if (!bothPlayersReady) return;
  if (phase !== "aim") return; // prevent aiming if over
  if (myPlayer === 0) return; 
  if (phase === "over") return;
  if (currentPlayer !== myPlayer) return;

  const puck = getCurrentPuck();
  if (!puck) return;

  aiming = true;
  aimPos = getMouse(e);
};

canvas.onmousemove = e => {
  if (!aiming) return;
  aimPos = getMouse(e);
};

canvas.onmouseup = async e => {
  if (!aiming) return;
  aiming = false;

  const puck = getCurrentPuck();
  if (!puck) return; // No puck left for this player

  const stateRef = ref(db, `rooms/${roomCode}/state`);
  const snap = await get(stateRef);
  const s = snap.val();

  const end = getMouse(e);
  puck.vx = (puck.x - end.x) * 0.1;
  puck.vy = (puck.y - end.y) * 0.1;

  s.shotsTaken[`player${myPlayer}`]++;

  // Check if both players have finished their shots
  if (
    s.shotsTaken.player1 >= getActivePucks(1).length &&
    s.shotsTaken.player2 >= getActivePucks(2).length
  ) {
    s.phase = "move";
  } else if (s.shotsTaken[`player${myPlayer}`] >= getActivePucks(myPlayer).length) {
    // Switch to the next player if current player is out of pucks
    s.currentPlayer = myPlayer === 1 ? 2 : 1;
  }

  await update(stateRef, {
    pucks,
    shotsTaken: s.shotsTaken,
    currentPlayer: s.currentPlayer,
    phase: s.phase
  });
};


canvas.addEventListener("touchstart", e => {
  if (!bothPlayersReady) return;
  if (phase !== "aim") return;
  if (myPlayer === 0) return; 
  if (currentPlayer !== myPlayer) return;

  const puck = getCurrentPuck();
  if (!puck) return;

  e.preventDefault(); // stop scrolling
  aiming = true;
  aimPos = getTouchPos(e.touches[0]);
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  if (!aiming) return;
  e.preventDefault();
  aimPos = getTouchPos(e.touches[0]);
}, { passive: false });

canvas.addEventListener("touchend", async e => {
  if (!aiming) return;
  aiming = false;

  const puck = getCurrentPuck();
  if (!puck) return;

  const stateRef = ref(db, `rooms/${roomCode}/state`);
  const snap = await get(stateRef);
  const s = snap.val();

  const end = aimPos;

  puck.vx = (puck.x - end.x) * 0.1;
  puck.vy = (puck.y - end.y) * 0.1;

  s.shotsTaken[`player${myPlayer}`]++;

  if (
    s.shotsTaken.player1 >= getActivePucks(1).length &&
    s.shotsTaken.player2 >= getActivePucks(2).length
  ) {
    s.phase = "move";
  } else if (s.shotsTaken[`player${myPlayer}`] >= getActivePucks(myPlayer).length) {
    s.currentPlayer = myPlayer === 1 ? 2 : 1;
  }

  await update(stateRef, {
    pucks,
    shotsTaken: s.shotsTaken,
    currentPlayer: s.currentPlayer,
    phase: s.phase
  });
}, { passive: false });

/* ================= STATE SYNC ================= */
let stateShots = { player1: 0, player2: 0 };

async function resetRound() {
  if (!roomCode) return;

  // Remove pucks that are inactive or off the board
  pucks = pucks.filter(p => 
    p.active &&
    p.x >= 0 && p.x <= canvas.width &&
    p.y >= 0 && p.y <= canvas.height
  );

  // Reset shots for the next round
  stateShots = { player1: 0, player2: 0 };

  // Set phase back to aim, start with Player 1
  phase = "aim";
  currentPlayer = 1;

  // Update Firebase state
  await update(ref(db, `rooms/${roomCode}/state`), {
    pucks,
    shotsTaken: stateShots,
    phase,
    currentPlayer
  });
}

  
function listenPlayers() {
  onValue(ref(db, `rooms/${roomCode}/players`), snap => {
    const p = snap.val();
    bothPlayersReady = p.player1 && p.player2;
  });
}

function listenState() {
  // Listen for game state
onValue(ref(db, `rooms/${roomCode}/state`), snap => {
  if (!snap.exists()) return;
  const s = snap.val();

  pucks = s.pucks || [];
  phase = s.phase;
  currentPlayer = s.currentPlayer;
  stateShots = s.shotsTaken;

  const turnEl = document.getElementById("turnIndicator");

  if (phase === "aim") {
    if (currentPlayer === myPlayer) {
      turnEl.textContent = "ðŸŽ¯ Your turn â€” set your target";
      turnEl.style.color = "#0f0";
    } else {
      turnEl.textContent = `â³ Player ${currentPlayer} is aiming`;
      turnEl.style.color = "#fff";
    }
  } else if (phase === "move") {
    turnEl.textContent = "ðŸ’¥ Pucks moving...";
    turnEl.style.color = "#ff0";
  } else if (phase === "over") {
    turnEl.textContent = "ðŸ Round over";
    turnEl.style.color = "#f55";
  }
});


  // Listen for scores separately
  onValue(ref(db, `rooms/${roomCode}/scores`), snap => {
    const scores = snap.val() || { player1: 0, player2: 0 };
    document.getElementById("player1Wins").textContent = scores.player1;
    document.getElementById("player2Wins").textContent = scores.player2;
  });
}

/* ================= HOST PHYSICS ================= */
function updateGame() {
  if (!isHost) return;
  if (phase !== "move") return;

  let moving = false;

  for (let p of pucks) {
    if (!p.active) continue;

    p.x += p.vx;
    p.y += p.vy;

    p.vx *= FRICTION;
    p.vy *= FRICTION;

    if (
      p.x < 0 || p.x > canvas.width ||
      p.y < 0 || p.y > canvas.height
    ) {
      p.active = false;
    }

    if (p.active && (p.vx !== 0 || p.vy !== 0)) moving = true;
  }

  // Puck collisions (same as before)...
  for (let i = 0; i < pucks.length; i++) {
    for (let j = i + 1; j < pucks.length; j++) {
      let p1 = pucks[i];
      let p2 = pucks[j];
      if (!p1.active || !p2.active) continue;

      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let dist = Math.hypot(dx, dy);
      let minDist = PUCK_RADIUS * 2;

      if (dist < minDist) {
        let overlap = minDist - dist;
        let nx = dx / dist;
        let ny = dy / dist;

        p1.x -= nx * overlap / 2;
        p1.y -= ny * overlap / 2;
        p2.x += nx * overlap / 2;
        p2.y += ny * overlap / 2;

        let tx = -ny;
        let ty = nx;
        let dpTan1 = p1.vx * tx + p1.vy * ty;
        let dpTan2 = p2.vx * tx + p2.vy * ty;
        let dpNorm1 = p1.vx * nx + p1.vy * ny;
        let dpNorm2 = p2.vx * nx + p2.vy * ny;

        let m1 = dpNorm2;
        let m2 = dpNorm1;
        p1.vx = tx * dpTan1 + nx * m1;
        p1.vy = ty * dpTan1 + ny * m1;
        p2.vx = tx * dpTan2 + nx * m2;
        p2.vy = ty * dpTan2 + ny * m2;

        p1.vx *= 0.9;
        p1.vy *= 0.9;
        p2.vx *= 0.9;
        p2.vy *= 0.9;
      }
    }
  }

  // Stop slow pucks
  for (let p of pucks) {
    if (!p.active) continue;

    if (Math.abs(p.vx) < 0.05) p.vx = 0;
    if (Math.abs(p.vy) < 0.05) p.vy = 0;
  }

  // ðŸ”¹ Check for win/lose before resetting
  checkWinLose();

  // Only reset if nothing is moving AND game is not over
  if (!moving && phase !== "over") {
    resetRound();
  }

  update(ref(db, `rooms/${roomCode}/state`), { pucks });
}

async function resetBoard() {
  if (!roomCode) return;

  // Reset all pucks to initial positions
  pucks = [];
  createPucks();

  // Reset shots and phase
  stateShots = { player1: 0, player2: 0 };
  phase = "aim";
  currentPlayer = 1;

  // Update Firebase state
  await update(ref(db, `rooms/${roomCode}/state`), {
    pucks,
    shotsTaken: stateShots,
    phase,
    currentPlayer
  });
}
  
function checkWinLose() {
  if (roundEnded) return; // Prevent multiple updates

  const p1Pucks = getActivePucks(1).length;
  const p2Pucks = getActivePucks(2).length;

  if (p1Pucks === 0 && p2Pucks === 0) return; // draw

  let winner = null;
  if (p1Pucks === 0 && p2Pucks > 0) winner = 2;
  if (p2Pucks === 0 && p1Pucks > 0) winner = 1;

  if (winner) {
    roundEnded = true;

    const overlay = document.getElementById("gameOver");
    const text = document.getElementById("gameOverText");
    overlay.style.display = "block";
    text.textContent = myPlayer === winner ? "YOU WIN!" : "YOU LOSE!";

    phase = "over";

    // ðŸ”¹ Only the host updates Firebase scores
    if (isHost) {
      const scoreRef = ref(db, `rooms/${roomCode}/scores/player${winner}`);
      get(scoreRef).then(snap => {
        const newScore = (snap.val() || 0) + 1;
        set(scoreRef, newScore);
      });
    }

    // ðŸ”¹ Start next round after 3 seconds
    setTimeout(async () => {
      overlay.style.display = "none";
      roundEnded = false;
      await resetBoard();
    }, 3000);
  }
}
  
/* ================= DRAW ================= */
function draw() {
  ctx.clearRect(0,0,800,500);
  ctx.strokeRect(BOARD_MARGIN,BOARD_MARGIN,760,460);

  // Draw pucks
  for (let p of pucks) {
    ctx.beginPath();
    ctx.arc(p.x,p.y,PUCK_RADIUS,0,Math.PI*2);
    ctx.fillStyle = p.player === 1 ? "#f44" : "#44f";
    ctx.fill();
  }

  // Draw aiming arrow
  if (phase === "aim" && aiming && aimPos) {
    const puck = getCurrentPuck();
    if (puck) {
      const startX = puck.x;
      const startY = puck.y;
      const endX = aimPos.x;
      const endY = aimPos.y;

      // Line
      ctx.beginPath();
      ctx.moveTo(startX, startY);
      ctx.lineTo(endX, endY);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Arrowhead
      const angle = Math.atan2(endY - startY, endX - startX);
      const headLength = 10;
      ctx.beginPath();
      ctx.moveTo(endX, endY);
      ctx.lineTo(endX - headLength * Math.cos(angle - Math.PI / 6),
                 endY - headLength * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(endX - headLength * Math.cos(angle + Math.PI / 6),
                 endY - headLength * Math.sin(angle + Math.PI / 6));
      ctx.lineTo(endX, endY);
      ctx.fillStyle = "white";
      ctx.fill();
    }
  }
}

function getMouse(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function getTouchPos(touch) {
  const r = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - r.left,
    y: touch.clientY - r.top
  };
}

function initGame() {
  createPucks();
  set(ref(db, `rooms/${roomCode}/state/pucks`), pucks);
}

/* ================= LOOP ================= */
function loop() {
  updateGame();
  draw();
  requestAnimationFrame(loop);
  checkWinLose();

}
loop();

</script>
</body>
</html>
