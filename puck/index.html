<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Puck Duel Online</title>

<style>
body {
  background: #222;
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
}

canvas {
  background: #0a5;
  border: 4px solid #333;
  margin-top: 10px;
}

#lobby {
  margin-bottom: 10px;
}

#status {
  margin-top: 6px;
  font-weight: bold;
}
</style>
</head>

<body>

<h1>Puck Duel</h1>

<div id="lobby">
  <button id="createBtn">Create Room</button>
  <input id="codeInput" placeholder="Room code" />
  <button id="joinBtn">Join Room</button>
  <div id="status">
    Room: <span id="roomLabel">-</span> |
    You: <span id="playerLabel">-</span>
  </div>
</div>

<canvas id="game" width="800" height="500"></canvas>

<div id="gameOver" style="
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 48px;
  color: white;
  background: rgba(0,0,0,0.8);
  padding: 40px;
  border-radius: 20px;
  display: none;
  text-align: center;
  z-index: 100;">
  <span id="gameOverText"></span>
</div>

  
<script type="module">
/* ================= FIREBASE ================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  get,
  update,
  onValue
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDxoIs6Nn5dMCpPj8JjNqbv-O3SVpiac0A",
  authDomain: "login-6cdd8.firebaseapp.com",
  databaseURL: "https://login-6cdd8-default-rtdb.firebaseio.com",
  projectId: "login-6cdd8",
  storageBucket: "login-6cdd8.firebasestorage.app",
  messagingSenderId: "518535069226",
  appId: "1:518535069226:web:8925106a250805bbf24d53"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ================= LOBBY ================= */
let roomCode = null;
let myPlayer = null;
let isHost = false;
let bothPlayersReady = false;

function generateCode() {
  return Math.random().toString(36).substring(2, 7).toUpperCase();
}

document.getElementById("createBtn").onclick = async () => {
  const code = generateCode();

  await set(ref(db, "rooms/" + code), {
    players: { player1: true, player2: false },
    state: {
      phase: "aim",
      currentPlayer: 1,
      shotsTaken: { player1: 0, player2: 0 },
      maxShots: 3,
      pucks: []
    }
  });

  roomCode = code;
  myPlayer = 1;
  isHost = true;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 1";

  initGame();
  listenPlayers();
  listenState();
};

document.getElementById("joinBtn").onclick = async () => {
  const code = document.getElementById("codeInput").value.toUpperCase();
  const snap = await get(ref(db, "rooms/" + code));

  if (!snap.exists()) return alert("Room not found");
  if (snap.val().players.player2) return alert("Room full");

  await update(ref(db, "rooms/" + code + "/players"), { player2: true });

  roomCode = code;
  myPlayer = 2;
  isHost = false;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 2";

  listenPlayers();
  listenState();
};

/* ================= GAME ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const BOARD_MARGIN = 20;
const PUCK_RADIUS = 12;
const FRICTION = 0.99;

let pucks = [];
let phase = "aim";
let currentPlayer = 1;
let aiming = false;
let aimPos = null;

function createPucks() {
  pucks = [];
  for (let i = 0; i < 3; i++) {
    pucks.push({ x: 150, y: 150 + i*60, vx: 0, vy: 0, player: 1, active: true });
    pucks.push({ x: 650, y: 150 + i*60, vx: 0, vy: 0, player: 2, active: true });
  }
}

function getActivePucks(player) {
  return pucks.filter(p => p.player === player && p.active);
}

function getCurrentPuck() {
  const list = getActivePucks(currentPlayer);
  const idx = stateShots[`player${currentPlayer}`];

  // If player has no more pucks, return null
  if (!list || idx >= list.length) return null;

  return list[idx];
}



/* ================= INPUT ================= */
canvas.onmousedown = e => {
  if (!bothPlayersReady) return;
  if (phase !== "aim") return; // prevent aiming if over
  if (phase === "over") return;
  if (currentPlayer !== myPlayer) return;

  const puck = getCurrentPuck();
  if (!puck) return;

  aiming = true;
  aimPos = getMouse(e);
};

canvas.onmousemove = e => {
  if (!aiming) return;
  aimPos = getMouse(e);
};

canvas.onmouseup = async e => {
  if (!aiming) return;
  aiming = false;

  const puck = getCurrentPuck();
  if (!puck) return; // No puck left for this player

  const stateRef = ref(db, `rooms/${roomCode}/state`);
  const snap = await get(stateRef);
  const s = snap.val();

  const end = getMouse(e);
  puck.vx = (puck.x - end.x) * 0.1;
  puck.vy = (puck.y - end.y) * 0.1;

  s.shotsTaken[`player${myPlayer}`]++;

  // Check if both players have finished their shots
  if (
    s.shotsTaken.player1 >= getActivePucks(1).length &&
    s.shotsTaken.player2 >= getActivePucks(2).length
  ) {
    s.phase = "move";
  } else if (s.shotsTaken[`player${myPlayer}`] >= getActivePucks(myPlayer).length) {
    // Switch to the next player if current player is out of pucks
    s.currentPlayer = myPlayer === 1 ? 2 : 1;
  }

  await update(stateRef, {
    pucks,
    shotsTaken: s.shotsTaken,
    currentPlayer: s.currentPlayer,
    phase: s.phase
  });
};


/* ================= STATE SYNC ================= */
let stateShots = { player1: 0, player2: 0 };

async function resetRound() {
  if (!roomCode) return;

  // Remove pucks that are inactive or off the board
  pucks = pucks.filter(p => 
    p.active &&
    p.x >= 0 && p.x <= canvas.width &&
    p.y >= 0 && p.y <= canvas.height
  );

  // Reset shots for the next round
  stateShots = { player1: 0, player2: 0 };

  // Set phase back to aim, start with Player 1
  phase = "aim";
  currentPlayer = 1;

  // Update Firebase state
  await update(ref(db, `rooms/${roomCode}/state`), {
    pucks,
    shotsTaken: stateShots,
    phase,
    currentPlayer
  });
}

  
function listenPlayers() {
  onValue(ref(db, `rooms/${roomCode}/players`), snap => {
    const p = snap.val();
    bothPlayersReady = p.player1 && p.player2;
  });
}

function listenState() {
  onValue(ref(db, `rooms/${roomCode}/state`), snap => {
    if (!snap.exists()) return;
    const s = snap.val();
    pucks = s.pucks || [];
    phase = s.phase;
    currentPlayer = s.currentPlayer;
    stateShots = s.shotsTaken;
  });
}

/* ================= HOST PHYSICS ================= */
function updateGame() {
  if (!isHost) return;
  if (phase !== "move") return;

  let moving = false;

  for (let p of pucks) {
    if (!p.active) continue;

    p.x += p.vx;
    p.y += p.vy;

    p.vx *= FRICTION;
    p.vy *= FRICTION;

    if (
      p.x < 0 || p.x > canvas.width ||
      p.y < 0 || p.y > canvas.height
    ) {
      p.active = false;
    }

    if (p.active && (p.vx !== 0 || p.vy !== 0)) moving = true;
  }

  // Puck collisions (same as before)...
  for (let i = 0; i < pucks.length; i++) {
    for (let j = i + 1; j < pucks.length; j++) {
      let p1 = pucks[i];
      let p2 = pucks[j];
      if (!p1.active || !p2.active) continue;

      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let dist = Math.hypot(dx, dy);
      let minDist = PUCK_RADIUS * 2;

      if (dist < minDist) {
        let overlap = minDist - dist;
        let nx = dx / dist;
        let ny = dy / dist;

        p1.x -= nx * overlap / 2;
        p1.y -= ny * overlap / 2;
        p2.x += nx * overlap / 2;
        p2.y += ny * overlap / 2;

        let tx = -ny;
        let ty = nx;
        let dpTan1 = p1.vx * tx + p1.vy * ty;
        let dpTan2 = p2.vx * tx + p2.vy * ty;
        let dpNorm1 = p1.vx * nx + p1.vy * ny;
        let dpNorm2 = p2.vx * nx + p2.vy * ny;

        let m1 = dpNorm2;
        let m2 = dpNorm1;
        p1.vx = tx * dpTan1 + nx * m1;
        p1.vy = ty * dpTan1 + ny * m1;
        p2.vx = tx * dpTan2 + nx * m2;
        p2.vy = ty * dpTan2 + ny * m2;

        p1.vx *= 0.9;
        p1.vy *= 0.9;
        p2.vx *= 0.9;
        p2.vy *= 0.9;
      }
    }
  }

  // Stop slow pucks
  for (let p of pucks) {
    if (!p.active) continue;

    if (Math.abs(p.vx) < 0.05) p.vx = 0;
    if (Math.abs(p.vy) < 0.05) p.vy = 0;
  }

  // ðŸ”¹ Check for win/lose before resetting
  checkWinLose();

  // Only reset if nothing is moving AND game is not over
  if (!moving && phase !== "over") {
    resetRound();
  }

  update(ref(db, `rooms/${roomCode}/state`), { pucks });
}

function checkWinLose() {
  const p1Pucks = getActivePucks(1).length;
  const p2Pucks = getActivePucks(2).length;

  if (p1Pucks === 0 && p2Pucks === 0) return; // draw, continue or do nothing

  let winner = null;
  if (p1Pucks === 0 && p2Pucks > 0) winner = 2;
  if (p2Pucks === 0 && p1Pucks > 0) winner = 1;

  if (winner) {
    const overlay = document.getElementById("gameOver");
    const text = document.getElementById("gameOverText");
    overlay.style.display = "block";
    if (myPlayer === winner) {
      text.textContent = "YOU WIN!";
    } else {
      text.textContent = "YOU LOSE!";
    }

    // Stop further actions
    phase = "over";
  }
}

  
/* ================= DRAW ================= */
function draw() {
  ctx.clearRect(0,0,800,500);
  ctx.strokeRect(BOARD_MARGIN,BOARD_MARGIN,760,460);

  for (let p of pucks) {
    ctx.beginPath();
    ctx.arc(p.x,p.y,PUCK_RADIUS,0,Math.PI*2);
    ctx.fillStyle = p.player === 1 ? "#f44" : "#44f";
    ctx.fill();
  }

  if (aiming && aimPos) {
    const puck = getCurrentPuck();
    if (puck) {
      ctx.beginPath();
      ctx.moveTo(puck.x,puck.y);
      ctx.lineTo(aimPos.x,aimPos.y);
      ctx.strokeStyle = "white";
      ctx.stroke();
    }
  }
}

function getMouse(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function initGame() {
  createPucks();
  set(ref(db, `rooms/${roomCode}/state/pucks`), pucks);
}

/* ================= LOOP ================= */
function loop() {
  updateGame();
  draw();
  requestAnimationFrame(loop);
  checkWinLose();

}
loop();

</script>
</body>
</html>
