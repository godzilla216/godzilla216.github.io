<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Puck Duel Online</title>

<style>
body {
  background: #222;
  color: white;
  font-family: Arial, sans-serif;
  text-align: center;
}

canvas {
  background: #0a5;
  border: 4px solid #333;
  margin-top: 10px;
  touch-action: none;
}

#lobby {
  margin-bottom: 10px;
}

#status {
  margin-top: 6px;
  font-weight: bold;
}
</style>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
</head>

<body>

<h1>Puck Duel</h1>

<div id="lobby">
  <button id="createBtn">Create Room</button>
  <input id="codeInput" placeholder="Room code" />
  <button id="joinBtn">Join Room</button>
  <button id="matchBtn">Quick Match</button>
  <button id="spectateBtn">Spectate</button>
  <div id="message" style="margin-top:6px; color:#f55; font-weight:bold;"></div>

  <div id="status">
    Room: <span id="roomLabel">-</span> |
    You: <span id="playerLabel">-</span>
  </div>
<div id="playerStats" style="margin-top:6px; font-size:16px; color:#0ff;">
  Online: 0 | Searching: 0
</div>
</div>

<div id="scoreboard" style="margin-bottom: 10px; font-size: 20px;">
  Player 1 Wins: <span id="player1Wins">0</span> |
  Player 2 Wins: <span id="player2Wins">0</span>
</div>

<div id="turnIndicator" style="margin-top:6px; font-size:18px; font-weight:bold;">
  Waiting for players...
</div>
  
<canvas id="game" width="800" height="500"></canvas>

<div id="gameOver" style="
  position: absolute;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-size: 48px;
  color: white;
  background: rgba(0,0,0,0.8);
  padding: 40px;
  border-radius: 20px;
  display: none;
  text-align: center;
  z-index: 100;">
  <span id="gameOverText"></span>
</div>

  
<script type="module">
/* ================= FIREBASE ================= */
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase,
  ref,
  set,
  get,
  update,
  onValue
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyDxoIs6Nn5dMCpPj8JjNqbv-O3SVpiac0A",
  authDomain: "login-6cdd8.firebaseapp.com",
  databaseURL: "https://login-6cdd8-default-rtdb.firebaseio.com",
  projectId: "login-6cdd8",
  storageBucket: "login-6cdd8.firebasestorage.app",
  messagingSenderId: "518535069226",
  appId: "1:518535069226:web:8925106a250805bbf24d53"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

/* ================= LOBBY ================= */



  
const playerStatsEl = document.getElementById("playerStats");

// --- Track online players ---
const myId = uid();
const onlineRef = ref(db, `presence/${myId}`);

// Mark this client as online
set(onlineRef, { connectedAt: Date.now() });

// Remove on disconnect
import { onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";
onDisconnect(onlineRef).remove();

// --- Realtime listener for online players ---
const presenceRef = ref(db, "presence");
onValue(presenceRef, snap => {
  const onlineUsers = snap.val() || {};
  updatePlayerStats(Object.keys(onlineUsers).length);
});

// --- Realtime listener for queue ---
const queueRef = ref(db, "matchmaking/queue");
onValue(queueRef, snap => {
  const queueUsers = snap.val() || {};
  updatePlayerStats(null, Object.keys(queueUsers).length);
});

// --- Helper to update combined text ---
let lastOnline = 0;
let lastQueue = 0;
let lastTime = performance.now();
const FIXED_TIMESTEP = 1 / 60; // 60Hz physics
let accumulator = 0;

function updatePlayerStats(online = null, queue = null) {
  if (online !== null) lastOnline = online;
  if (queue !== null) lastQueue = queue;

  playerStatsEl.textContent = `Online: ${lastOnline} | Searching: ${lastQueue}`;
}



let roomCode = null;
let myPlayer = null;
let isHost = false;
let bothPlayersReady = false;

const messageEl = document.getElementById("message");

document.getElementById("spectateBtn").onclick = async () => {
  const code = document.getElementById("codeInput").value.toUpperCase();
  if (!code) {
    messageEl.textContent = "Please enter a room code.";
    return;
  }

  const snap = await get(ref(db, "rooms/" + code));
  if (!snap.exists()) {
    messageEl.textContent = "Room not found.";
    return;
  }

  // Clear message on success
  messageEl.textContent = "";

  roomCode = code;
  myPlayer = 0; // 0 = spectator
  isHost = false; // spectators never host

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Spectator";

  bothPlayersReady = true; // allow state to be drawn
  aiming = false;

  listenState();

  document.getElementById("status").textContent = "Spectating";
};


  
function uid() {
  return Math.random().toString(36).substring(2);
}

const myMatchId = uid();
let inQueue = false;

window.addEventListener("beforeunload", () => {
  if (inQueue) {
    set(ref(db, `matchmaking/queue/${myMatchId}`), null);
  }
});
  
function generateCode() {
  return Math.random().toString(36).substring(2, 7).toUpperCase();
}
let roundEnded = false
document.getElementById("createBtn").onclick = async () => {
  const code = generateCode();

  await set(ref(db, "rooms/" + code), {
    players: { player1: true, player2: false },
    state: {
      phase: "aim",
      currentPlayer: 1,
      shotsTaken: { player1: 0, player2: 0 },
      maxShots: 3,
      pucks: []
    },
    scores: { player1: 0, player2: 0 } // add this
  });

  roomCode = code;
  myPlayer = 1;
  isHost = true;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 1";

if (isHost) {
  initGame();
}

listenPlayers();
listenState();
};

document.getElementById("joinBtn").onclick = async () => {
  const code = document.getElementById("codeInput").value.toUpperCase();
  const snap = await get(ref(db, "rooms/" + code));

  if (!snap.exists()) return alert("Room not found");
  if (snap.val().players.player2) return alert("Room full");

  await update(ref(db, "rooms/" + code + "/players"), { player2: true });

  roomCode = code;
  myPlayer = 2;
  isHost = false;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = "Player 2";

  listenPlayers();
  listenState();
};

/* ==================== */

document.getElementById("matchBtn").onclick = async () => {
  if (inQueue) return;
  inQueue = true;

  document.getElementById("roomLabel").textContent = "â€”";
  document.getElementById("playerLabel").textContent = "Matching";

  const myRef = ref(db, `matchmaking/queue/${myMatchId}`);
  await set(myRef, { joinedAt: Date.now() });

  const queueRef = ref(db, "matchmaking/queue");

  onValue(queueRef, async snap => {
    if (!inQueue) return;

    const queue = snap.val() || {};
    const ids = Object.keys(queue);

    // Need at least 2 people
    if (ids.length < 2) return;

    // Oldest player becomes host
    ids.sort((a, b) => queue[a].joinedAt - queue[b].joinedAt);

    if (ids[0] !== myMatchId) return; // not the host

    const otherId = ids[1];
    const code = generateCode();

    await set(ref(db, `rooms/${code}`), {
      players: { player1: true, player2: true },
      state: {
        phase: "aim",
        currentPlayer: 1,
        shotsTaken: { player1: 0, player2: 0 },
        maxShots: 3,
        pucks: []
      },
      scores: { player1: 0, player2: 0 }
    });

    await set(ref(db, `matchmaking/matches/${ids[0]}`), {
      room: code,
      player: 1
    });

    await set(ref(db, `matchmaking/matches/${ids[1]}`), {
      room: code,
      player: 2
    });

    await set(ref(db, `matchmaking/queue/${ids[0]}`), null);
    await set(ref(db, `matchmaking/queue/${ids[1]}`), null);

    inQueue = false;
  });

  waitForMatch();
};
  /*========================================================*/
  function waitForMatch() {
  onValue(ref(db, `matchmaking/matches/${myMatchId}`), snap => {
    if (!snap.exists()) return;

    const { room, player } = snap.val();
    joinMatchedRoom(room, player);

    set(ref(db, `matchmaking/queue/${myMatchId}`), null);
    set(ref(db, `matchmaking/matches/${myMatchId}`), null);
  });
}

function joinMatchedRoom(code, playerNum) {
  roomCode = code;
  myPlayer = playerNum;
  isHost = playerNum === 1;

  document.getElementById("roomLabel").textContent = code;
  document.getElementById("playerLabel").textContent = `Player ${playerNum}`;

  initGame();
  listenPlayers();
  listenState();

  document.getElementById("status").textContent = "Matched!";
}

/* ================= GAME ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const BOARD_MARGIN = 20;
const PUCK_RADIUS = 12;
const FRICTION = 0.965;

let pucks = [];
let phase = "aim";
let currentPlayer = 1;
let aiming = false;
let aimPos = null;

// ===== PORTALS =====
let portal = null; 
// portal = { x, y, exitX, exitY, radius }
const PORTAL_RADIUS = 18;
let portalAnim = 0; // animation timer
const PORTAL_CHANCE = 0.6; // 40% chance per round

// ===== GRAVITY WELL =====
let gravityWell = null;
// gravityWell = { x, y, radius, strength }
const GRAVITY_WELL_CHANCE = 0.5; // 50%
const GRAVITY_RADIUS = 180;
const GRAVITY_STRENGTH = 122;

  
function createPucks() {
  pucks = [];
  for (let i = 0; i < 3; i++) {
    pucks.push({ x: 150, y: 150 + i*60, vx: 0, vy: 0, player: 1, active: true });
    pucks.push({ x: 650, y: 150 + i*60, vx: 0, vy: 0, player: 2, active: true });
  }
}

function getActivePucks(player) {
  return pucks.filter(p => p.player === player && p.active);
}

function getCurrentPuck() {
  const list = getActivePucks(currentPlayer);
  const idx = stateShots[`player${currentPlayer}`];

  // If player has no more pucks, return null
  if (!list || idx >= list.length) return null;

  return list[idx];
}



/* ================= INPUT ================= */
canvas.onmousedown = e => {
  if (!bothPlayersReady) return;
  if (phase !== "aim") return; // prevent aiming if over
  if (myPlayer === 0) return; 
  if (phase === "over") return;
  if (currentPlayer !== myPlayer) return;

  const puck = getCurrentPuck();
  if (!puck) return;

  aiming = true;
  aimPos = getMouse(e);
};

canvas.onmousemove = e => {
  if (!aiming) return;
  aimPos = getMouse(e);
};

canvas.onmouseup = async e => {
  if (!aiming) return;
  aiming = false;

  const puck = getCurrentPuck();
  if (!puck) return; // No puck left for this player

  const stateRef = ref(db, `rooms/${roomCode}/state`);
  const snap = await get(stateRef);
  const s = snap.val();

  const end = getMouse(e);
  puck.vx = (puck.x - end.x) * 0.1;
  puck.vy = (puck.y - end.y) * 0.1;

  s.shotsTaken[`player${myPlayer}`]++;

  // Check if both players have finished their shots
  if (
    s.shotsTaken.player1 >= getActivePucks(1).length &&
    s.shotsTaken.player2 >= getActivePucks(2).length
  ) {
    s.phase = "move";
  } else if (s.shotsTaken[`player${myPlayer}`] >= getActivePucks(myPlayer).length) {
    // Switch to the next player if current player is out of pucks
    s.currentPlayer = myPlayer === 1 ? 2 : 1;
  }

  await update(stateRef, {
    pucks,
    shotsTaken: s.shotsTaken,
    currentPlayer: s.currentPlayer,
    phase: s.phase
  });
};


canvas.addEventListener("touchstart", e => {
  if (!bothPlayersReady) return;
  if (phase !== "aim") return;
  if (myPlayer === 0) return; 
  if (currentPlayer !== myPlayer) return;

  const puck = getCurrentPuck();
  if (!puck) return;

  e.preventDefault(); // stop scrolling
  aiming = true;
  aimPos = getTouchPos(e.touches[0]);
}, { passive: false });

canvas.addEventListener("touchmove", e => {
  if (!aiming) return;
  e.preventDefault();
  aimPos = getTouchPos(e.touches[0]);
}, { passive: false });

canvas.addEventListener("touchend", async e => {
  if (!aiming) return;
  aiming = false;

  const puck = getCurrentPuck();
  if (!puck) return;

  const stateRef = ref(db, `rooms/${roomCode}/state`);
  const snap = await get(stateRef);
  const s = snap.val();

  const end = aimPos;

  puck.vx = (puck.x - end.x) * 0.1;
  puck.vy = (puck.y - end.y) * 0.1;

  s.shotsTaken[`player${myPlayer}`]++;

  if (
    s.shotsTaken.player1 >= getActivePucks(1).length &&
    s.shotsTaken.player2 >= getActivePucks(2).length
  ) {
    s.phase = "move";
  } else if (s.shotsTaken[`player${myPlayer}`] >= getActivePucks(myPlayer).length) {
    s.currentPlayer = myPlayer === 1 ? 2 : 1;
  }

  await update(stateRef, {
    pucks,
    shotsTaken: s.shotsTaken,
    currentPlayer: s.currentPlayer,
    phase: s.phase
  });
}, { passive: false });

/* ================= STATE SYNC ================= */
let stateShots = { player1: 0, player2: 0 };

async function resetRound() {
  if (!roomCode) return;

  // Remove pucks that are inactive or off the board
  pucks = pucks.filter(p => 
    p.active &&
    p.x >= 0 && p.x <= canvas.width &&
    p.y >= 0 && p.y <= canvas.height
  );

  // Reset shots for the next round
  stateShots = { player1: 0, player2: 0 };

  // Set phase back to aim, start with Player 1
  phase = "aim";
  currentPlayer = 1;

// ðŸŸ£ Spawn portal (host only, 40% chance)
if (isHost && Math.random() < PORTAL_CHANCE) {
  portal = {
    x: Math.random() * (canvas.width - 200) + 100,
    y: Math.random() * (canvas.height - 200) + 100,
    exitX: Math.random() * (canvas.width - 200) + 100,
    exitY: Math.random() * (canvas.height - 200) + 100,
    radius: PORTAL_RADIUS
  };
} else {
  portal = null;
}

// ðŸŒ€ Spawn gravity well (host only, 50% chance, center)
if (isHost && Math.random() < GRAVITY_WELL_CHANCE) {
  gravityWell = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    radius: GRAVITY_RADIUS,
    strength: GRAVITY_STRENGTH
  };
} else {
  gravityWell = null;
}

  
  // Update Firebase state
await update(ref(db, `rooms/${roomCode}/state`), {
  pucks,
  shotsTaken: stateShots,
  phase,
  currentPlayer,
  portal,
  gravityWell
});
}

  
function listenPlayers() {
  onValue(ref(db, `rooms/${roomCode}/players`), snap => {
    const p = snap.val();
    bothPlayersReady = p.player1 && p.player2;
  });
}

function listenState() {
  // Listen for game state
onValue(ref(db, `rooms/${roomCode}/state`), snap => {
  if (!snap.exists()) return;
  const s = snap.val();

  pucks = s.pucks || [];
  phase = s.phase;
  currentPlayer = s.currentPlayer;
  stateShots = s.shotsTaken;
  portal = s.portal || null;
  gravityWell = s.gravityWell || null;


  
  const turnEl = document.getElementById("turnIndicator");

  if (phase === "aim") {
    if (currentPlayer === myPlayer) {
      turnEl.textContent = "ðŸŽ¯ Your turn â€” set your target";
      turnEl.style.color = "#0f0";
    } else {
      turnEl.textContent = `â³ Player ${currentPlayer} is aiming`;
      turnEl.style.color = "#fff";
    }
  } else if (phase === "move") {
    turnEl.textContent = "ðŸ’¥ Pucks moving...";
    turnEl.style.color = "#ff0";
  } else if (phase === "over") {
    turnEl.textContent = "ðŸ Round over";
    turnEl.style.color = "#f55";
  }
});


  // Listen for scores separately
  onValue(ref(db, `rooms/${roomCode}/scores`), snap => {
    const scores = snap.val() || { player1: 0, player2: 0 };
    document.getElementById("player1Wins").textContent = scores.player1;
    document.getElementById("player2Wins").textContent = scores.player2;
  });
}

/* ================= HOST PHYSICS ================= */
function updateGame(dt) {
  if (!isHost) return;
  if (phase !== "move") return;

  let moving = false;

  for (let p of pucks) {
    if (!p.active) continue;

// ðŸŒ€ Gravity well force (host only)
// ðŸŒ€ Gravity well force
// ðŸŒ€ SLINGSHOT GRAVITY WELL
if (gravityWell) {
  const dx = gravityWell.x - p.x;
  const dy = gravityWell.y - p.y;
  const dist = Math.hypot(dx, dy);

  if (dist > 15 && dist < gravityWell.radius) {
    const nx = dx / dist;
    const ny = dy / dist;

    // Strong pull curve (NOT inverse-square)
    const pull =
      (1 - dist / gravityWell.radius) *
      gravityWell.strength *
      dt;

    // Inward acceleration
    p.vx += nx * pull;
    p.vy += ny * pull;

    // ðŸš€ Tangential boost near center (THIS creates slingshots)
    const tangentBoost = (1 - dist / gravityWell.radius) * 0.6;
    p.vx += -ny * tangentBoost;
    p.vy += nx * tangentBoost;
  }
}



    
p.x += p.vx * dt * 60;
p.y += p.vy * dt * 60;

const friction = Math.pow(FRICTION, dt * 60);
p.vx *= friction;
p.vy *= friction;

// ðŸ”’ Cap max speed (prevents infinite motion / explosions)
const maxSpeed = 18;
const speed = Math.hypot(p.vx, p.vy);
if (speed > maxSpeed) {
  p.vx = (p.vx / speed) * maxSpeed;
  p.vy = (p.vy / speed) * maxSpeed;
}


    // ðŸŒ€ Portal teleport (host only)
if (portal) {
  for (let p of pucks) {
    if (!p.active) continue;

    const dx = p.x - portal.x;
    const dy = p.y - portal.y;
    const dist = Math.hypot(dx, dy);

    if (dist < portal.radius + PUCK_RADIUS) {
      p.x = portal.exitX;
      p.y = portal.exitY;

      // prevent instant re-teleport
      p.vx += (Math.random() - 0.5) * 2;
      p.vy += (Math.random() - 0.5) * 2;
    }
  }
}

    
    if (
      p.x < 0 || p.x > canvas.width ||
      p.y < 0 || p.y > canvas.height
    ) {
      p.active = false;
    }

    if (p.active && (p.vx !== 0 || p.vy !== 0)) moving = true;
  }

  // Puck collisions (same as before)...
  for (let i = 0; i < pucks.length; i++) {
    for (let j = i + 1; j < pucks.length; j++) {
      let p1 = pucks[i];
      let p2 = pucks[j];
      if (!p1.active || !p2.active) continue;

      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let dist = Math.hypot(dx, dy);
      let minDist = PUCK_RADIUS * 2;

      if (dist < minDist) {
        let overlap = minDist - dist;
        let nx = dx / dist;
        let ny = dy / dist;

        p1.x -= nx * overlap / 2;
        p1.y -= ny * overlap / 2;
        p2.x += nx * overlap / 2;
        p2.y += ny * overlap / 2;

        let tx = -ny;
        let ty = nx;
        let dpTan1 = p1.vx * tx + p1.vy * ty;
        let dpTan2 = p2.vx * tx + p2.vy * ty;
        let dpNorm1 = p1.vx * nx + p1.vy * ny;
        let dpNorm2 = p2.vx * nx + p2.vy * ny;

        let m1 = dpNorm2;
        let m2 = dpNorm1;
        p1.vx = tx * dpTan1 + nx * m1;
        p1.vy = ty * dpTan1 + ny * m1;
        p2.vx = tx * dpTan2 + nx * m2;
        p2.vy = ty * dpTan2 + ny * m2;

        p1.vx *= 0.9;
        p1.vy *= 0.9;
        p2.vx *= 0.9;
        p2.vy *= 0.9;
      }
    }
  }

  // Stop slow pucks
  for (let p of pucks) {
    if (!p.active) continue;

    if (Math.abs(p.vx) < 0.05) p.vx = 0;
    if (Math.abs(p.vy) < 0.05) p.vy = 0;
  }

  // ðŸ”¹ Check for win/lose before resetting
  checkWinLose();

  // Only reset if nothing is moving AND game is not over
  if (!moving && phase !== "over") {
    resetRound();
  }

  update(ref(db, `rooms/${roomCode}/state`), { pucks });
}

async function resetBoard() {
  if (!roomCode) return;

  // Reset all pucks to initial positions
  pucks = [];
  createPucks();

  // Reset shots and phase
  stateShots = { player1: 0, player2: 0 };
  phase = "aim";
  currentPlayer = 1;

  // Update Firebase state
  await update(ref(db, `rooms/${roomCode}/state`), {
    pucks,
    shotsTaken: stateShots,
    phase,
    currentPlayer
  });
}
  
function checkWinLose() {
  if (roundEnded) return; // Prevent multiple updates

  const p1Pucks = getActivePucks(1).length;
  const p2Pucks = getActivePucks(2).length;

  if (p1Pucks === 0 && p2Pucks === 0) return; // draw

  let winner = null;
  if (p1Pucks === 0 && p2Pucks > 0) winner = 2;
  if (p2Pucks === 0 && p1Pucks > 0) winner = 1;

  if (winner) {
    roundEnded = true;

    const overlay = document.getElementById("gameOver");
    const text = document.getElementById("gameOverText");
    overlay.style.display = "block";
    text.textContent = myPlayer === winner ? "YOU WIN!" : "YOU LOSE!";

    phase = "over";

    // ðŸ”¹ Only the host updates Firebase scores
    if (isHost) {
      const scoreRef = ref(db, `rooms/${roomCode}/scores/player${winner}`);
      get(scoreRef).then(snap => {
        const newScore = (snap.val() || 0) + 1;
        set(scoreRef, newScore);
      });
    }

    // ðŸ”¹ Start next round after 3 seconds
    setTimeout(async () => {
      overlay.style.display = "none";
      roundEnded = false;
      await resetBoard();
    }, 3000);
  }
}
  
/* ================= DRAW ================= */
function draw() {
  ctx.clearRect(0, 0, 800, 500);
  ctx.strokeRect(BOARD_MARGIN, BOARD_MARGIN, 760, 460);

  // ðŸŒ€ Draw gravity well
if (gravityWell) {
  const pulse = Math.sin(portalAnim * 2) * 6;

  ctx.beginPath();
  ctx.arc(gravityWell.x, gravityWell.y, 30 + pulse, 0, Math.PI * 2);
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(gravityWell.x, gravityWell.y, gravityWell.radius, 0, Math.PI * 2);
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 2;
  ctx.stroke();
}

  
  // ðŸŸ£ Draw portal

if (portal) {
  drawPortal(portal.x, portal.y, portal.radius, "purple");
  drawPortal(portal.exitX, portal.exitY, portal.radius, "#ff66ff");
}

  // Draw pucks
  for (let p of pucks) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, PUCK_RADIUS, 0, Math.PI * 2);
    ctx.fillStyle = p.player === 1 ? "#f44" : "#44f";
    ctx.fill();
  }

  if (aiming && aimPos && phase === "aim") {
    const puck = getCurrentPuck();
    if (puck) {
      // Small dotted line from puck to cursor
      ctx.beginPath();
      ctx.setLineDash([5, 5]); // 5px dash, 5px gap
      ctx.moveTo(puck.x, puck.y);
      ctx.lineTo(aimPos.x, aimPos.y);
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.setLineDash([]); // reset to solid

      // Arrow in opposite direction to show power
      const arrowEndX = puck.x - (aimPos.x - puck.x);
      const arrowEndY = puck.y - (aimPos.y - puck.y);
      drawArrow(puck.x, puck.y, arrowEndX, arrowEndY);
    }
  }
}

/* ================= HELPER: Draw Arrow ================= */
function drawArrow(x1, y1, x2, y2) {
  const headLength = 15; // length of arrow tip
  const dx = x2 - x1;
  const dy = y2 - y1;
  const angle = Math.atan2(dy, dx);

  // Main line
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.stroke();

  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(x2, y2);
  ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI/6), y2 - headLength * Math.sin(angle - Math.PI/6));
  ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI/6), y2 - headLength * Math.sin(angle + Math.PI/6));
  ctx.lineTo(x2, y2);
  ctx.fillStyle = "white";
  ctx.fill();
}

function drawPortal(x, y, r, color) {
  const pulse = Math.sin(portalAnim * 2) * 3;
  const glow = Math.abs(Math.sin(portalAnim)) * 10;

  // Outer glow
  ctx.beginPath();
  ctx.arc(x, y, r + glow, 0, Math.PI * 2);
  ctx.strokeStyle = color;
  ctx.globalAlpha = 0.2;
  ctx.lineWidth = 8;
  ctx.stroke();
  ctx.globalAlpha = 1;

  // Rotating swirl
  for (let i = 0; i < 6; i++) {
    const angle = portalAnim + (i * Math.PI / 3);
    ctx.beginPath();
    ctx.arc(x, y, r + pulse, angle, angle + Math.PI / 2);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.stroke();
  }

  // Core ring
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.strokeStyle = "white";
  ctx.lineWidth = 2;
  ctx.stroke();
}


function getMouse(e) {
  const r = canvas.getBoundingClientRect();
  return { x: e.clientX - r.left, y: e.clientY - r.top };
}

function getTouchPos(touch) {
  const r = canvas.getBoundingClientRect();
  return {
    x: touch.clientX - r.left,
    y: touch.clientY - r.top
  };
}

function initGame() {
  createPucks();
  set(ref(db, `rooms/${roomCode}/state/pucks`), pucks);
}

/* ================= LOOP ================= */
function loop(now) {
  const deltaTime = (now - lastTime) / 1000;
  lastTime = now;
  accumulator += deltaTime;

  portalAnim += deltaTime * 3;

  while (accumulator >= FIXED_TIMESTEP) {
    updateGame(FIXED_TIMESTEP);
    accumulator -= FIXED_TIMESTEP;
  }

  draw();
  requestAnimationFrame(loop);
}

requestAnimationFrame(loop);


</script>
</body>
</html>
